<#@ template debug="false" hostspecific="false" language="C#" #><#@ output extension=".cs" #><# int[] dimensionsToGenerate = new int[] { 1, 2, 3, 4, 5, 6, 7 }; #>//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "Link.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Towel.Structures
{
	/// <summary>Represents a link between objects.</summary>
	public interface Link : Structure<object>
	{
		#region Properties
		
		/// <summary>The number of objects in the tuple.</summary>
		int Size { get; }
		#endregion
	}<# foreach (int i in dimensionsToGenerate) { #>

	/// <summary>Represents a link between objects.</summary><# for (int j = 1; j <= i; j++) { #>
	/// <typeparam name="T<#= j #>">The type of #<#= j #> element in the link.</typeparam><# } #>
	[System.Serializable]
	public class Link<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>> : Link
	{
		// Fields<# for (int j = 1; j <= i; j++) { #>
		private T<#= j #> __<#= j #>;<# } #>

		#region Constructors
		
		/// <summary>Creates a link between objects.</summary>
<# for (int j = 1; j <= i; j++) { #>
		/// <param name="_<#= j #>">The #<#= j #> item to be linked.</param>
<# } #>
		/// <remarks>Runtime: O(1).</remarks>
		public Link(T1 _1<# for (int j = 2; j <= i; j++) { #>, T<#= j #> _<#= j #><# } #>)
		{<# for (int j = 1; j <= i; j++) { #>
			this.__<#= j #> = _<#= j #>;<# } #>
		}
		
		#endregion

		#region Properties
		
		/// <summary>The number of objects in the tuple.</summary>
		public	int Size { get { return <#= i #>; } }
		
<# for (int j = 1; j <= i; j++) { #>

		/// <summary>The #<#= j #> item in the link.</summary>
		/// <remarks>Runtime: O(1).</remarks>
		public T<#= j #> _<#= j #> { get { return this.__<#= j #>; } set { this.__<#= j #> = value; } }
<# } #>

		#endregion

		#region Methods<# if (i < 8) { #>

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		public static explicit operator Link<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>(System.Tuple<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>> tuple)
		{
			return new Link<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>(tuple.Item1<# for (int j = 2; j <= i; j++) { #>, tuple.Item<#= j #><# } #>);
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		public static explicit operator System.Tuple<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>(Link<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>> link)
		{
			return new System.Tuple<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>((T1)link._1<# for (int j = 2; j <= i; j++) { #>, (T<#= j #>)link._<#= j #><# } #>);
		}<# } #>
		
		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{<# for (int j = 1; j <= i; j++) { #>
			yield return this._<#= j #>;<# } #>
		}
		
		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{<# for (int j = 1; j <= i; j++) { #>
			yield return this._<#= j #>;<# } #>
		}
		
		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)<# for (int j = 1; j <= i; j++) { #>,
				typeof(T<#= j #>)<# } #>
			};
		}
		
		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Compare<object> compare)
		{<# for (int j = 1; j <= i; j++) { #>
			if (compare(this._<#= j #>, item) == Comparison.Equal)
				return true;<# } #>
			return false;
		}
		
		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public bool Contains<Key>(Key key, Compare<object, Key> compare)
		{<# for (int j = 1; j <= i; j++) { #>
			if (compare(this._<#= j #>, key) == Comparison.Equal)
				return true;<# } #>
			return false;
		}
		
		/// <summary>Invokes a delegate for each entry in the data structure.</summary>
		/// <param name="function">The delegate to invoke on each item in the structure.</param>
		public void Stepper(Step<object> function)
		{<# for (int j = 1; j <= i; j++) { #>
			function(this._<#= j #>);<# } #>
		}
		
		/// <summary>Invokes a delegate for each entry in the data structure.</summary>
		/// <param name="function">The delegate to invoke on each item in the structure.</param>
		/// <returns>The resulting status of the iteration.</returns>
		public	StepStatus Stepper(StepBreak<object> function)
		{<# for (int j = 1; j <= i; j++) { #>
			if (function(this._<#= j #>) == StepStatus.Break)
				return StepStatus.Break;<# } #>
			return StepStatus.Continue;
		}
		
		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	Structure<object> Clone()
		{
			return new Link<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>((T1)this._1<# for (int j = 2; j <= i; j++) { #>, this._<#= j #><# } #>);
		}
		
		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1<# for (int j = 2; j <= i; j++) { #>,
				this._<#= j #><# } #>
			};
		}

		public override int GetHashCode()
		{
			return this._1.GetHashCode()<# for (int j = 2; j <= i; j++) { #>

				^ this._<#= j #>.GetHashCode()<# } #>;
		}

		public override bool Equals(object obj)
		{
<# for (int j = 1; j <= i; j++) { #>
			if (!(obj as Link<T1<# for (int k = 2; k <= i; k++) { #>, T<#= k #><# } #>>)._<#= j #>.Equals(this._<#= j #>))
				return false;
<# } #>
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary><# for (int j = 1; j <= i; j++) { #>
	/// <typeparam name="T<#= j #>">The type of #<#= j #> element in the link.</typeparam><# } #>
	[System.Serializable]
	public struct LinkStruct<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>> : Link
	{
		// Fields<# for (int j = 1; j <= i; j++) { #>
		private T<#= j #> __<#= j #>;<# } #>

		#region Constructors
		
		/// <summary>Creates a link between objects.</summary>
<# for (int j = 1; j <= i; j++) { #>
		/// <param name="_<#= j #>">The #<#= j #> item to be linked.</param>
<# } #>
		/// <remarks>Runtime: O(1).</remarks>
		public LinkStruct(T1 _1<# for (int j = 2; j <= i; j++) { #>, T<#= j #> _<#= j #><# } #>)
		{<# for (int j = 1; j <= i; j++) { #>
			this.__<#= j #> = _<#= j #>;<# } #>
		}
		
		#endregion

		#region Properties
		
		/// <summary>The number of objects in the tuple.</summary>
		public	int Size { get { return <#= i #>; } }
		
<# for (int j = 1; j <= i; j++) { #>

		/// <summary>The #<#= j #> item in the link.</summary>
		/// <remarks>Runtime: O(1).</remarks>
		public T<#= j #> _<#= j #> { get { return this.__<#= j #>; } set { this.__<#= j #> = value; } }
<# } #>

		#endregion

		#region Methods<# if (i < 8) { #>

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		public static explicit operator LinkStruct<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>(System.Tuple<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>> tuple)
		{
			return new LinkStruct<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>(tuple.Item1<# for (int j = 2; j <= i; j++) { #>, tuple.Item<#= j #><# } #>);
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		public static explicit operator System.Tuple<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>(LinkStruct<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>> link)
		{
			return new System.Tuple<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>((T1)link._1<# for (int j = 2; j <= i; j++) { #>, (T<#= j #>)link._<#= j #><# } #>);
		}<# } #>
		
		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{<# for (int j = 1; j <= i; j++) { #>
			yield return this._<#= j #>;<# } #>
		}
		
		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{<# for (int j = 1; j <= i; j++) { #>
			yield return this._<#= j #>;<# } #>
		}
		
		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)<# for (int j = 1; j <= i; j++) { #>,
				typeof(T<#= j #>)<# } #>
			};
		}
		
		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Compare<object> compare)
		{<# for (int j = 1; j <= i; j++) { #>
			if (compare(this._<#= j #>, item) == Comparison.Equal)
				return true;<# } #>
			return false;
		}
		
		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public bool Contains<Key>(Key key, Compare<object, Key> compare)
		{<# for (int j = 1; j <= i; j++) { #>
			if (compare(this._<#= j #>, key) == Comparison.Equal)
				return true;<# } #>
			return false;
		}
		
		/// <summary>Invokes a delegate for each entry in the data structure.</summary>
		/// <param name="function">The delegate to invoke on each item in the structure.</param>
		public void Stepper(Step<object> function)
		{<# for (int j = 1; j <= i; j++) { #>
			function(this._<#= j #>);<# } #>
		}
		
		/// <summary>Invokes a delegate for each entry in the data structure.</summary>
		/// <param name="function">The delegate to invoke on each item in the structure.</param>
		/// <returns>The resulting status of the iteration.</returns>
		public StepStatus Stepper(StepBreak<object> function)
		{<# for (int j = 1; j <= i; j++) { #>
			if (function(this._<#= j #>) == StepStatus.Break)
				return StepStatus.Break;<# } #>
			return StepStatus.Continue;
		}
		
		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public Structure<object> Clone()
		{
			return new LinkStruct<T1<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>>((T1)this._1<# for (int j = 2; j <= i; j++) { #>, this._<#= j #><# } #>);
		}
		
		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1<# for (int j = 2; j <= i; j++) { #>,
				this._<#= j #><# } #>
			};
		}

		public override int GetHashCode()
		{
			return this._1.GetHashCode()<# for (int j = 2; j <= i; j++) { #>

				^ this._<#= j #>.GetHashCode()<# } #>;
		}

		public override bool Equals(object obj)
		{
				if (!(obj is LinkStruct<T1<# for (int k = 2; k <= i; k++) { #>, T<#= k #><# } #>>))
					 return false;

				LinkStruct<T1<# for (int k = 2; k <= i; k++) { #>, T<#= k #><# } #>> linkStruct = (LinkStruct<T1<# for (int k = 2; k <= i; k++) { #>, T<#= k #><# } #>>)obj;
<# for (int j = 1; j <= i; j++) { #>
			if (!linkStruct._<#= j #>.Equals(this._<#= j #>))
				return false;
<# } #>
			return true;
		}

		#endregion
	}
	<# } #>
}