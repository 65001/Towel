//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "MEASUREMENTS.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Towel.Mathematics;

namespace Towel.Measurements
{
	#region Acceleration

	/// <summary>An Acceleration measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Acceleration measurement.</typeparam>
    [Serializable]
    public struct Acceleration<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Acceleration.Units, T>();
        internal T _measurement;
        internal Acceleration.Units _units;

        #region Constructors

        /// <summary>Constructs an Acceleration with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Acceleration.</param>
        /// <param name="units">The units of the Acceleration.</param>
        public Acceleration(T measurement, Acceleration.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Acceleration.</summary>
        public Acceleration.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Acceleration.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Acceleration<T> Add(Acceleration<T> a, Acceleration<T> b)
        {
            Acceleration.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Acceleration<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Acceleration<T> operator +(Acceleration<T> a, Acceleration<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Acceleration<T> Subtract(Acceleration<T> a, Acceleration<T> b)
        {
            Acceleration.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Acceleration<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Acceleration<T> operator -(Acceleration<T> a, Acceleration<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Acceleration<T> Multiply(Acceleration<T> a, T b)
        {
            return new Acceleration<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Acceleration<T> Multiply(T b, Acceleration<T> a)
        {
            return new Acceleration<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Acceleration<T> operator *(Acceleration<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Acceleration<T> operator *(T b, Acceleration<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Acceleration<T> Divide(Acceleration<T> a, T b)
        {
            return new Acceleration<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Acceleration<T> operator /(Acceleration<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Acceleration<T> a, Acceleration<T> b)
        {
            Acceleration.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Acceleration<T> a, Acceleration<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Acceleration<T> a, Acceleration<T> b)
        {
            Acceleration.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Acceleration<T> a, Acceleration<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Acceleration<T> a, Acceleration<T> b)
        {
            Acceleration.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Acceleration<T> a, Acceleration<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Acceleration<T> a, Acceleration<T> b)
        {
            Acceleration.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Acceleration<T> left, Acceleration<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Acceleration<T> a, Acceleration<T> b)
        {
            Acceleration.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Acceleration<T> a, Acceleration<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Acceleration<T> a, Acceleration<T> b)
        {
            Acceleration.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Acceleration<T> a, Acceleration<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Acceleration<T>)
            {
                return this == ((Acceleration<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Angle

	/// <summary>An Angle measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Angle measurement.</typeparam>
    [Serializable]
    public struct Angle<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Angle.Units, T>();
        internal T _measurement;
        internal Angle.Units _units;

        #region Constructors

        /// <summary>Constructs an Angle with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Angle.</param>
        /// <param name="units">The units of the Angle.</param>
        public Angle(T measurement, Angle.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Angle.</summary>
        public Angle.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Angle.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Angle<T> Add(Angle<T> a, Angle<T> b)
        {
            Angle.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Angle<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Angle<T> operator +(Angle<T> a, Angle<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Angle<T> Subtract(Angle<T> a, Angle<T> b)
        {
            Angle.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Angle<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Angle<T> operator -(Angle<T> a, Angle<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Angle<T> Multiply(Angle<T> a, T b)
        {
            return new Angle<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Angle<T> Multiply(T b, Angle<T> a)
        {
            return new Angle<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Angle<T> operator *(Angle<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Angle<T> operator *(T b, Angle<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Angle<T> Divide(Angle<T> a, T b)
        {
            return new Angle<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Angle<T> operator /(Angle<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Angle<T> a, Angle<T> b)
        {
            Angle.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Angle<T> a, Angle<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Angle<T> a, Angle<T> b)
        {
            Angle.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Angle<T> a, Angle<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Angle<T> a, Angle<T> b)
        {
            Angle.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Angle<T> a, Angle<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Angle<T> a, Angle<T> b)
        {
            Angle.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Angle<T> left, Angle<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Angle<T> a, Angle<T> b)
        {
            Angle.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Angle<T> a, Angle<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Angle<T> a, Angle<T> b)
        {
            Angle.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Angle<T> a, Angle<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Angle<T>)
            {
                return this == ((Angle<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Attenuation

	/// <summary>An Attenuation measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Attenuation measurement.</typeparam>
    [Serializable]
    public struct Attenuation<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Attenuation.Units, T>();
        internal T _measurement;
        internal Attenuation.Units _units;

        #region Constructors

        /// <summary>Constructs an Attenuation with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Attenuation.</param>
        /// <param name="units">The units of the Attenuation.</param>
        public Attenuation(T measurement, Attenuation.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Attenuation.</summary>
        public Attenuation.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Attenuation.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Attenuation<T> Add(Attenuation<T> a, Attenuation<T> b)
        {
            Attenuation.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Attenuation<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Attenuation<T> operator +(Attenuation<T> a, Attenuation<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Attenuation<T> Subtract(Attenuation<T> a, Attenuation<T> b)
        {
            Attenuation.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Attenuation<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Attenuation<T> operator -(Attenuation<T> a, Attenuation<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Attenuation<T> Multiply(Attenuation<T> a, T b)
        {
            return new Attenuation<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Attenuation<T> Multiply(T b, Attenuation<T> a)
        {
            return new Attenuation<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Attenuation<T> operator *(Attenuation<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Attenuation<T> operator *(T b, Attenuation<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Attenuation<T> Divide(Attenuation<T> a, T b)
        {
            return new Attenuation<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Attenuation<T> operator /(Attenuation<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Attenuation<T> a, Attenuation<T> b)
        {
            Attenuation.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Attenuation<T> a, Attenuation<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Attenuation<T> a, Attenuation<T> b)
        {
            Attenuation.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Attenuation<T> a, Attenuation<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Attenuation<T> a, Attenuation<T> b)
        {
            Attenuation.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Attenuation<T> a, Attenuation<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Attenuation<T> a, Attenuation<T> b)
        {
            Attenuation.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Attenuation<T> left, Attenuation<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Attenuation<T> a, Attenuation<T> b)
        {
            Attenuation.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Attenuation<T> a, Attenuation<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Attenuation<T> a, Attenuation<T> b)
        {
            Attenuation.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Attenuation<T> a, Attenuation<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Attenuation<T>)
            {
                return this == ((Attenuation<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Current

	/// <summary>An Current measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Current measurement.</typeparam>
    [Serializable]
    public struct Current<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Current.Units, T>();
        internal T _measurement;
        internal Current.Units _units;

        #region Constructors

        /// <summary>Constructs an Current with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Current.</param>
        /// <param name="units">The units of the Current.</param>
        public Current(T measurement, Current.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Current.</summary>
        public Current.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Current.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Current<T> Add(Current<T> a, Current<T> b)
        {
            Current.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Current<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Current<T> operator +(Current<T> a, Current<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Current<T> Subtract(Current<T> a, Current<T> b)
        {
            Current.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Current<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Current<T> operator -(Current<T> a, Current<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Current<T> Multiply(Current<T> a, T b)
        {
            return new Current<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Current<T> Multiply(T b, Current<T> a)
        {
            return new Current<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Current<T> operator *(Current<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Current<T> operator *(T b, Current<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Current<T> Divide(Current<T> a, T b)
        {
            return new Current<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Current<T> operator /(Current<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Current<T> a, Current<T> b)
        {
            Current.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Current<T> a, Current<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Current<T> a, Current<T> b)
        {
            Current.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Current<T> a, Current<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Current<T> a, Current<T> b)
        {
            Current.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Current<T> a, Current<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Current<T> a, Current<T> b)
        {
            Current.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Current<T> left, Current<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Current<T> a, Current<T> b)
        {
            Current.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Current<T> a, Current<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Current<T> a, Current<T> b)
        {
            Current.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Current<T> a, Current<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Current<T>)
            {
                return this == ((Current<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Density

	/// <summary>An Density measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Density measurement.</typeparam>
    [Serializable]
    public struct Density<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Density.Units, T>();
        internal T _measurement;
        internal Density.Units _units;

        #region Constructors

        /// <summary>Constructs an Density with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Density.</param>
        /// <param name="units">The units of the Density.</param>
        public Density(T measurement, Density.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Density.</summary>
        public Density.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Density.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Density<T> Add(Density<T> a, Density<T> b)
        {
            Density.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Density<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Density<T> operator +(Density<T> a, Density<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Density<T> Subtract(Density<T> a, Density<T> b)
        {
            Density.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Density<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Density<T> operator -(Density<T> a, Density<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Density<T> Multiply(Density<T> a, T b)
        {
            return new Density<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Density<T> Multiply(T b, Density<T> a)
        {
            return new Density<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Density<T> operator *(Density<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Density<T> operator *(T b, Density<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Density<T> Divide(Density<T> a, T b)
        {
            return new Density<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Density<T> operator /(Density<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Density<T> a, Density<T> b)
        {
            Density.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Density<T> a, Density<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Density<T> a, Density<T> b)
        {
            Density.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Density<T> a, Density<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Density<T> a, Density<T> b)
        {
            Density.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Density<T> a, Density<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Density<T> a, Density<T> b)
        {
            Density.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Density<T> left, Density<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Density<T> a, Density<T> b)
        {
            Density.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Density<T> a, Density<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Density<T> a, Density<T> b)
        {
            Density.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Density<T> a, Density<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Density<T>)
            {
                return this == ((Density<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Energy

	/// <summary>An Energy measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Energy measurement.</typeparam>
    [Serializable]
    public struct Energy<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Energy.Units, T>();
        internal T _measurement;
        internal Energy.Units _units;

        #region Constructors

        /// <summary>Constructs an Energy with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Energy.</param>
        /// <param name="units">The units of the Energy.</param>
        public Energy(T measurement, Energy.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Energy.</summary>
        public Energy.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Energy.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Energy<T> Add(Energy<T> a, Energy<T> b)
        {
            Energy.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Energy<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Energy<T> operator +(Energy<T> a, Energy<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Energy<T> Subtract(Energy<T> a, Energy<T> b)
        {
            Energy.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Energy<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Energy<T> operator -(Energy<T> a, Energy<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Energy<T> Multiply(Energy<T> a, T b)
        {
            return new Energy<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Energy<T> Multiply(T b, Energy<T> a)
        {
            return new Energy<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Energy<T> operator *(Energy<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Energy<T> operator *(T b, Energy<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Energy<T> Divide(Energy<T> a, T b)
        {
            return new Energy<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Energy<T> operator /(Energy<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Energy<T> a, Energy<T> b)
        {
            Energy.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Energy<T> a, Energy<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Energy<T> a, Energy<T> b)
        {
            Energy.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Energy<T> a, Energy<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Energy<T> a, Energy<T> b)
        {
            Energy.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Energy<T> a, Energy<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Energy<T> a, Energy<T> b)
        {
            Energy.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Energy<T> left, Energy<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Energy<T> a, Energy<T> b)
        {
            Energy.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Energy<T> a, Energy<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Energy<T> a, Energy<T> b)
        {
            Energy.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Energy<T> a, Energy<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Energy<T>)
            {
                return this == ((Energy<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Force

	/// <summary>An Force measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Force measurement.</typeparam>
    [Serializable]
    public struct Force<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Force.Units, T>();
        internal T _measurement;
        internal Force.Units _units;

        #region Constructors

        /// <summary>Constructs an Force with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Force.</param>
        /// <param name="units">The units of the Force.</param>
        public Force(T measurement, Force.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Force.</summary>
        public Force.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Force.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Force<T> Add(Force<T> a, Force<T> b)
        {
            Force.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Force<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Force<T> operator +(Force<T> a, Force<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Force<T> Subtract(Force<T> a, Force<T> b)
        {
            Force.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Force<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Force<T> operator -(Force<T> a, Force<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Force<T> Multiply(Force<T> a, T b)
        {
            return new Force<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Force<T> Multiply(T b, Force<T> a)
        {
            return new Force<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Force<T> operator *(Force<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Force<T> operator *(T b, Force<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Force<T> Divide(Force<T> a, T b)
        {
            return new Force<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Force<T> operator /(Force<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Force<T> a, Force<T> b)
        {
            Force.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Force<T> a, Force<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Force<T> a, Force<T> b)
        {
            Force.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Force<T> a, Force<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Force<T> a, Force<T> b)
        {
            Force.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Force<T> a, Force<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Force<T> a, Force<T> b)
        {
            Force.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Force<T> left, Force<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Force<T> a, Force<T> b)
        {
            Force.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Force<T> a, Force<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Force<T> a, Force<T> b)
        {
            Force.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Force<T> a, Force<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Force<T>)
            {
                return this == ((Force<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Length

	/// <summary>An Length measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Length measurement.</typeparam>
    [Serializable]
    public struct Length<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Length.Units, T>();
        internal T _measurement;
        internal Length.Units _units;

        #region Constructors

        /// <summary>Constructs an Length with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Length.</param>
        /// <param name="units">The units of the Length.</param>
        public Length(T measurement, Length.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Length.</summary>
        public Length.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Length.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Length<T> Add(Length<T> a, Length<T> b)
        {
            Length.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Length<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Length<T> operator +(Length<T> a, Length<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Length<T> Subtract(Length<T> a, Length<T> b)
        {
            Length.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Length<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Length<T> operator -(Length<T> a, Length<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Length<T> Multiply(Length<T> a, T b)
        {
            return new Length<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Length<T> Multiply(T b, Length<T> a)
        {
            return new Length<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Length<T> operator *(Length<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Length<T> operator *(T b, Length<T> a)
        {
            return Multiply(b, a);
        }
		
		public static Speed<T> operator *(Length<T> a, Time<T> b)
        {
            throw new NotImplementedException();
        }
		
        #endregion

        #region Divide

        public static Length<T> Divide(Length<T> a, T b)
        {
            return new Length<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Length<T> operator /(Length<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Length<T> a, Length<T> b)
        {
            Length.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Length<T> a, Length<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Length<T> a, Length<T> b)
        {
            Length.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Length<T> a, Length<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Length<T> a, Length<T> b)
        {
            Length.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Length<T> a, Length<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Length<T> a, Length<T> b)
        {
            Length.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Length<T> left, Length<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Length<T> a, Length<T> b)
        {
            Length.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Length<T> a, Length<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Length<T> a, Length<T> b)
        {
            Length.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Length<T> a, Length<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Length<T>)
            {
                return this == ((Length<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Luminosity

	/// <summary>An Luminosity measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Luminosity measurement.</typeparam>
    [Serializable]
    public struct Luminosity<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Luminosity.Units, T>();
        internal T _measurement;
        internal Luminosity.Units _units;

        #region Constructors

        /// <summary>Constructs an Luminosity with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Luminosity.</param>
        /// <param name="units">The units of the Luminosity.</param>
        public Luminosity(T measurement, Luminosity.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Luminosity.</summary>
        public Luminosity.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Luminosity.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Luminosity<T> Add(Luminosity<T> a, Luminosity<T> b)
        {
            Luminosity.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Luminosity<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Luminosity<T> operator +(Luminosity<T> a, Luminosity<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Luminosity<T> Subtract(Luminosity<T> a, Luminosity<T> b)
        {
            Luminosity.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Luminosity<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Luminosity<T> operator -(Luminosity<T> a, Luminosity<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Luminosity<T> Multiply(Luminosity<T> a, T b)
        {
            return new Luminosity<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Luminosity<T> Multiply(T b, Luminosity<T> a)
        {
            return new Luminosity<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Luminosity<T> operator *(Luminosity<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Luminosity<T> operator *(T b, Luminosity<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Luminosity<T> Divide(Luminosity<T> a, T b)
        {
            return new Luminosity<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Luminosity<T> operator /(Luminosity<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Luminosity<T> a, Luminosity<T> b)
        {
            Luminosity.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Luminosity<T> a, Luminosity<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Luminosity<T> a, Luminosity<T> b)
        {
            Luminosity.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Luminosity<T> a, Luminosity<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Luminosity<T> a, Luminosity<T> b)
        {
            Luminosity.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Luminosity<T> a, Luminosity<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Luminosity<T> a, Luminosity<T> b)
        {
            Luminosity.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Luminosity<T> left, Luminosity<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Luminosity<T> a, Luminosity<T> b)
        {
            Luminosity.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Luminosity<T> a, Luminosity<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Luminosity<T> a, Luminosity<T> b)
        {
            Luminosity.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Luminosity<T> a, Luminosity<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Luminosity<T>)
            {
                return this == ((Luminosity<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Mass

	/// <summary>An Mass measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Mass measurement.</typeparam>
    [Serializable]
    public struct Mass<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Mass.Units, T>();
        internal T _measurement;
        internal Mass.Units _units;

        #region Constructors

        /// <summary>Constructs an Mass with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Mass.</param>
        /// <param name="units">The units of the Mass.</param>
        public Mass(T measurement, Mass.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Mass.</summary>
        public Mass.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Mass.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Mass<T> Add(Mass<T> a, Mass<T> b)
        {
            Mass.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Mass<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Mass<T> operator +(Mass<T> a, Mass<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Mass<T> Subtract(Mass<T> a, Mass<T> b)
        {
            Mass.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Mass<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Mass<T> operator -(Mass<T> a, Mass<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Mass<T> Multiply(Mass<T> a, T b)
        {
            return new Mass<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Mass<T> Multiply(T b, Mass<T> a)
        {
            return new Mass<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Mass<T> operator *(Mass<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Mass<T> operator *(T b, Mass<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Mass<T> Divide(Mass<T> a, T b)
        {
            return new Mass<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Mass<T> operator /(Mass<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Mass<T> a, Mass<T> b)
        {
            Mass.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Mass<T> a, Mass<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Mass<T> a, Mass<T> b)
        {
            Mass.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Mass<T> a, Mass<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Mass<T> a, Mass<T> b)
        {
            Mass.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Mass<T> a, Mass<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Mass<T> a, Mass<T> b)
        {
            Mass.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Mass<T> left, Mass<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Mass<T> a, Mass<T> b)
        {
            Mass.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Mass<T> a, Mass<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Mass<T> a, Mass<T> b)
        {
            Mass.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Mass<T> a, Mass<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Mass<T>)
            {
                return this == ((Mass<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Power

	/// <summary>An Power measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Power measurement.</typeparam>
    [Serializable]
    public struct Power<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Power.Units, T>();
        internal T _measurement;
        internal Power.Units _units;

        #region Constructors

        /// <summary>Constructs an Power with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Power.</param>
        /// <param name="units">The units of the Power.</param>
        public Power(T measurement, Power.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Power.</summary>
        public Power.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Power.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Power<T> Add(Power<T> a, Power<T> b)
        {
            Power.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Power<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Power<T> operator +(Power<T> a, Power<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Power<T> Subtract(Power<T> a, Power<T> b)
        {
            Power.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Power<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Power<T> operator -(Power<T> a, Power<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Power<T> Multiply(Power<T> a, T b)
        {
            return new Power<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Power<T> Multiply(T b, Power<T> a)
        {
            return new Power<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Power<T> operator *(Power<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Power<T> operator *(T b, Power<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Power<T> Divide(Power<T> a, T b)
        {
            return new Power<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Power<T> operator /(Power<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Power<T> a, Power<T> b)
        {
            Power.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Power<T> a, Power<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Power<T> a, Power<T> b)
        {
            Power.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Power<T> a, Power<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Power<T> a, Power<T> b)
        {
            Power.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Power<T> a, Power<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Power<T> a, Power<T> b)
        {
            Power.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Power<T> left, Power<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Power<T> a, Power<T> b)
        {
            Power.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Power<T> a, Power<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Power<T> a, Power<T> b)
        {
            Power.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Power<T> a, Power<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Power<T>)
            {
                return this == ((Power<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Pressure

	/// <summary>An Pressure measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Pressure measurement.</typeparam>
    [Serializable]
    public struct Pressure<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Pressure.Units, T>();
        internal T _measurement;
        internal Pressure.Units _units;

        #region Constructors

        /// <summary>Constructs an Pressure with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Pressure.</param>
        /// <param name="units">The units of the Pressure.</param>
        public Pressure(T measurement, Pressure.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Pressure.</summary>
        public Pressure.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Pressure.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Pressure<T> Add(Pressure<T> a, Pressure<T> b)
        {
            Pressure.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Pressure<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Pressure<T> operator +(Pressure<T> a, Pressure<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Pressure<T> Subtract(Pressure<T> a, Pressure<T> b)
        {
            Pressure.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Pressure<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Pressure<T> operator -(Pressure<T> a, Pressure<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Pressure<T> Multiply(Pressure<T> a, T b)
        {
            return new Pressure<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Pressure<T> Multiply(T b, Pressure<T> a)
        {
            return new Pressure<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Pressure<T> operator *(Pressure<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Pressure<T> operator *(T b, Pressure<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Pressure<T> Divide(Pressure<T> a, T b)
        {
            return new Pressure<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Pressure<T> operator /(Pressure<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Pressure<T> a, Pressure<T> b)
        {
            Pressure.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Pressure<T> a, Pressure<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Pressure<T> a, Pressure<T> b)
        {
            Pressure.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Pressure<T> a, Pressure<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Pressure<T> a, Pressure<T> b)
        {
            Pressure.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Pressure<T> a, Pressure<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Pressure<T> a, Pressure<T> b)
        {
            Pressure.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Pressure<T> left, Pressure<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Pressure<T> a, Pressure<T> b)
        {
            Pressure.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Pressure<T> a, Pressure<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Pressure<T> a, Pressure<T> b)
        {
            Pressure.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Pressure<T> a, Pressure<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Pressure<T>)
            {
                return this == ((Pressure<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Speed

	/// <summary>An Speed measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Speed measurement.</typeparam>
    [Serializable]
    public struct Speed<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Speed.Units, T>();
        internal T _measurement;
        internal Speed.Units _units;

        #region Constructors

        /// <summary>Constructs an Speed with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Speed.</param>
        /// <param name="units">The units of the Speed.</param>
        public Speed(T measurement, Speed.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Speed.</summary>
        public Speed.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Speed.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Speed<T> Add(Speed<T> a, Speed<T> b)
        {
            Speed.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Speed<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Speed<T> operator +(Speed<T> a, Speed<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Speed<T> Subtract(Speed<T> a, Speed<T> b)
        {
            Speed.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Speed<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Speed<T> operator -(Speed<T> a, Speed<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Speed<T> Multiply(Speed<T> a, T b)
        {
            return new Speed<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Speed<T> Multiply(T b, Speed<T> a)
        {
            return new Speed<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Speed<T> operator *(Speed<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Speed<T> operator *(T b, Speed<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Speed<T> Divide(Speed<T> a, T b)
        {
            return new Speed<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Speed<T> operator /(Speed<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Speed<T> a, Speed<T> b)
        {
            Speed.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Speed<T> a, Speed<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Speed<T> a, Speed<T> b)
        {
            Speed.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Speed<T> a, Speed<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Speed<T> a, Speed<T> b)
        {
            Speed.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Speed<T> a, Speed<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Speed<T> a, Speed<T> b)
        {
            Speed.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Speed<T> left, Speed<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Speed<T> a, Speed<T> b)
        {
            Speed.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Speed<T> a, Speed<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Speed<T> a, Speed<T> b)
        {
            Speed.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Speed<T> a, Speed<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Speed<T>)
            {
                return this == ((Speed<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Tempurature

	/// <summary>An Tempurature measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Tempurature measurement.</typeparam>
    [Serializable]
    public struct Tempurature<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Tempurature.Units, T>();
        internal T _measurement;
        internal Tempurature.Units _units;

        #region Constructors

        /// <summary>Constructs an Tempurature with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Tempurature.</param>
        /// <param name="units">The units of the Tempurature.</param>
        public Tempurature(T measurement, Tempurature.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Tempurature.</summary>
        public Tempurature.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Tempurature.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Tempurature<T> Add(Tempurature<T> a, Tempurature<T> b)
        {
            Tempurature.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Tempurature<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Tempurature<T> operator +(Tempurature<T> a, Tempurature<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Tempurature<T> Subtract(Tempurature<T> a, Tempurature<T> b)
        {
            Tempurature.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Tempurature<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Tempurature<T> operator -(Tempurature<T> a, Tempurature<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Tempurature<T> Multiply(Tempurature<T> a, T b)
        {
            return new Tempurature<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Tempurature<T> Multiply(T b, Tempurature<T> a)
        {
            return new Tempurature<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Tempurature<T> operator *(Tempurature<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Tempurature<T> operator *(T b, Tempurature<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Tempurature<T> Divide(Tempurature<T> a, T b)
        {
            return new Tempurature<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Tempurature<T> operator /(Tempurature<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Tempurature<T> a, Tempurature<T> b)
        {
            Tempurature.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Tempurature<T> a, Tempurature<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Tempurature<T> a, Tempurature<T> b)
        {
            Tempurature.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Tempurature<T> a, Tempurature<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Tempurature<T> a, Tempurature<T> b)
        {
            Tempurature.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Tempurature<T> a, Tempurature<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Tempurature<T> a, Tempurature<T> b)
        {
            Tempurature.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Tempurature<T> left, Tempurature<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Tempurature<T> a, Tempurature<T> b)
        {
            Tempurature.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Tempurature<T> a, Tempurature<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Tempurature<T> a, Tempurature<T> b)
        {
            Tempurature.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Tempurature<T> a, Tempurature<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Tempurature<T>)
            {
                return this == ((Tempurature<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Time

	/// <summary>An Time measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Time measurement.</typeparam>
    [Serializable]
    public struct Time<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Time.Units, T>();
        internal T _measurement;
        internal Time.Units _units;

        #region Constructors

        /// <summary>Constructs an Time with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Time.</param>
        /// <param name="units">The units of the Time.</param>
        public Time(T measurement, Time.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Time.</summary>
        public Time.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Time.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Time<T> Add(Time<T> a, Time<T> b)
        {
            Time.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Time<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Time<T> operator +(Time<T> a, Time<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Time<T> Subtract(Time<T> a, Time<T> b)
        {
            Time.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Time<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Time<T> operator -(Time<T> a, Time<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Time<T> Multiply(Time<T> a, T b)
        {
            return new Time<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Time<T> Multiply(T b, Time<T> a)
        {
            return new Time<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Time<T> operator *(Time<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Time<T> operator *(T b, Time<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Time<T> Divide(Time<T> a, T b)
        {
            return new Time<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Time<T> operator /(Time<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Time<T> a, Time<T> b)
        {
            Time.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Time<T> a, Time<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Time<T> a, Time<T> b)
        {
            Time.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Time<T> a, Time<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Time<T> a, Time<T> b)
        {
            Time.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Time<T> a, Time<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Time<T> a, Time<T> b)
        {
            Time.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Time<T> left, Time<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Time<T> a, Time<T> b)
        {
            Time.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Time<T> a, Time<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Time<T> a, Time<T> b)
        {
            Time.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Time<T> a, Time<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Time<T>)
            {
                return this == ((Time<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Torque

	/// <summary>An Torque measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Torque measurement.</typeparam>
    [Serializable]
    public struct Torque<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Torque.Units, T>();
        internal T _measurement;
        internal Torque.Units _units;

        #region Constructors

        /// <summary>Constructs an Torque with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Torque.</param>
        /// <param name="units">The units of the Torque.</param>
        public Torque(T measurement, Torque.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Torque.</summary>
        public Torque.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Torque.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Torque<T> Add(Torque<T> a, Torque<T> b)
        {
            Torque.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Torque<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Torque<T> operator +(Torque<T> a, Torque<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Torque<T> Subtract(Torque<T> a, Torque<T> b)
        {
            Torque.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Torque<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Torque<T> operator -(Torque<T> a, Torque<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Torque<T> Multiply(Torque<T> a, T b)
        {
            return new Torque<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Torque<T> Multiply(T b, Torque<T> a)
        {
            return new Torque<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Torque<T> operator *(Torque<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Torque<T> operator *(T b, Torque<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Torque<T> Divide(Torque<T> a, T b)
        {
            return new Torque<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Torque<T> operator /(Torque<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Torque<T> a, Torque<T> b)
        {
            Torque.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Torque<T> a, Torque<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Torque<T> a, Torque<T> b)
        {
            Torque.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Torque<T> a, Torque<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Torque<T> a, Torque<T> b)
        {
            Torque.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Torque<T> a, Torque<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Torque<T> a, Torque<T> b)
        {
            Torque.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Torque<T> left, Torque<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Torque<T> a, Torque<T> b)
        {
            Torque.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Torque<T> a, Torque<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Torque<T> a, Torque<T> b)
        {
            Torque.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Torque<T> a, Torque<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Torque<T>)
            {
                return this == ((Torque<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion

	#region Volume

	/// <summary>An Volume measurement.</summary>
    /// <typeparam name="T">The generic numeric type used to store the Volume measurement.</typeparam>
    [Serializable]
    public struct Volume<T>
    {
        internal static T[][] Table = UnitConversionTable.Build<Volume.Units, T>();
        internal T _measurement;
        internal Volume.Units _units;

        #region Constructors

        /// <summary>Constructs an Volume with the specified measurement and units.</summary>
        /// <param name="measurement">The measurement of the Volume.</param>
        /// <param name="units">The units of the Volume.</param>
        public Volume(T measurement, Volume.Units units)
        {
            this._measurement = measurement;
            this._units = units;
        }

        #endregion

        #region Properties

        /// <summary>The current units used to represent the Volume.</summary>
        public Volume.Units Units
        {
            get { return this._units; }
            set
            {
                if (value != this._units)
                {
                    this._measurement = this[value];
                    this._units = value;
                }
            }
        }

        /// <summary>Gets the measurement in the desired units.</summary>
        /// <param name="units">The units you want the measurement to be in.</param>
        /// <returns>The measurement in the specified units.</returns>
        public T this[Volume.Units units]
        {
            get
            {
                if (this._units == units)
                {
                    return this._measurement;
                }
                else
                {
                    T factor = Table[(int)this._units][(int)units];
                    return Compute.Multiply(this._measurement, factor);
                }
            }
        }

        #endregion

        #region Mathematics

        #region Add

        public static Volume<T> Add(Volume<T> a, Volume<T> b)
        {
            Volume.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Volume<T>(Compute.Add(a[units], b[units]), units);
        }

        public static Volume<T> operator +(Volume<T> a, Volume<T> b)
        {
            return Add(a, b);
        }

        #endregion

        #region Subtract

        public static Volume<T> Subtract(Volume<T> a, Volume<T> b)
        {
            Volume.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return new Volume<T>(Compute.Subtract(a[units], b[units]), units);
        }

        public static Volume<T> operator -(Volume<T> a, Volume<T> b)
        {
            return Subtract(a, b);
        }

        #endregion

        #region Multiply

        public static Volume<T> Multiply(Volume<T> a, T b)
        {
            return new Volume<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Volume<T> Multiply(T b, Volume<T> a)
        {
            return new Volume<T>(Compute.Multiply(a._measurement, b), a._units);
        }

        public static Volume<T> operator *(Volume<T> a, T b)
        {
            return Multiply(a, b);
        }

        public static Volume<T> operator *(T b, Volume<T> a)
        {
            return Multiply(b, a);
        }
		
        #endregion

        #region Divide

        public static Volume<T> Divide(Volume<T> a, T b)
        {
            return new Volume<T>(Compute.Divide(a._measurement, b), a._units);
        }

        public static Volume<T> operator /(Volume<T> a, T b)
        {
            return Divide(a, b);
        }

        #endregion

        #region LessThan

        public static bool LessThan(Volume<T> a, Volume<T> b)
        {
            Volume.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThan(a[units], b[units]);
        }

        public static bool operator <(Volume<T> a, Volume<T> b)
        {
            return LessThan(a, b);
        }

        #endregion

        #region GreaterThan

        public static bool GreaterThan(Volume<T> a, Volume<T> b)
        {
            Volume.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThan(a[units], b[units]);
        }

        public static bool operator >(Volume<T> a, Volume<T> b)
        {
            return GreaterThan(a, b);
        }

        #endregion

        #region LessThanOrEqual

        public static bool LessThanOrEqual(Volume<T> a, Volume<T> b)
        {
            Volume.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.LessThanOrEqual(a[units], b[units]);
        }

        public static bool operator <=(Volume<T> a, Volume<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        #endregion

        #region GreaterThanOrEqual

        public static bool GreaterThanOrEqual(Volume<T> a, Volume<T> b)
        {
            Volume.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.GreaterThanOrEqual(a[units], b[units]);
        }

        public static bool operator >=(Volume<T> left, Volume<T> right)
        {
            return GreaterThanOrEqual(left, right);
        }

        #endregion

        #region Equal

        public static bool Equal(Volume<T> a, Volume<T> b)
        {
            Volume.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.Equal(a[units], b[units]);
        }

        public static bool operator ==(Volume<T> a, Volume<T> b)
        {
            return Equal(a, b);
        }

        public static bool NotEqual(Volume<T> a, Volume<T> b)
        {
            Volume.Units units = a.Units <= b.Units ? a.Units : b.Units;
            return Compute.NotEqual(a[units], b[units]);
        }

        public static bool operator !=(Volume<T> a, Volume<T> b)
        {
            return NotEqual(a, b);
        }

        #endregion

        #endregion

        #region Overrides

        public override string ToString()
        {
            switch (this._units)
            {
                default: return this._measurement + " " + this._units;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is Volume<T>)
            {
                return this == ((Volume<T>)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return this._measurement.GetHashCode() ^ this._units.GetHashCode();
        }

        #endregion
    }

	#endregion
}