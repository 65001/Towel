<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
string[] measurementTypes = new string[]
{
	"Acceleration",
	"Angle",
	"AngularAcceleration",
	"AngularSpeed",
	"Area",
	"AreaDensity",
	"Density",
	"ElectricCharge",
	"ElectricCurrent",
	"Force",
	"Length",
	"LinearDensity",
	"LinearMass",
	"LinearMassFlow",
	"Mass",
	"Speed",
	"Time",
	"Volume",
};
#>
//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "MEMBERGENERATOR.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

using Towel.Mathematics;

namespace Towel.Measurements
{
<# foreach (String type in measurementTypes) { #>
	public partial struct <#= type #><T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two <#= type #> measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static <#= type #><T> Add(<#= type #><T> a, <#= type #><T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two <#= type #> measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static <#= type #><T> operator +(<#= type #><T> a, <#= type #><T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two <#= type #> measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public <#= type #><T> Add(<#= type #><T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two <#= type #> measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static <#= type #><T> Subtract(<#= type #><T> a, <#= type #><T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two <#= type #> measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static <#= type #><T> operator -(<#= type #><T> a, <#= type #><T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two <#= type #> measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public <#= type #><T> Subtract(<#= type #><T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an <#= type #> by a scalar numeric value.</summary>
        /// <param name="a">The <#= type #> measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static <#= type #><T> Multiply(<#= type #><T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an <#= type #> by a scalar numeric value.</summary>
        /// <param name="a">The <#= type #> measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static <#= type #><T> Multiply(T b, <#= type #><T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an <#= type #> by a scalar numeric value.</summary>
        /// <param name="a">The <#= type #> measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static <#= type #><T> operator *(<#= type #><T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an <#= type #> by a scalar numeric value.</summary>
        /// <param name="a">The <#= type #> measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static <#= type #><T> operator *(T b, <#= type #><T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an <#= type #> by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public <#= type #><T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this <#= type #> measurement by a numaric scalar value.</summary>
        /// <param name="a">The <#= type #> measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static <#= type #><T> Divide(<#= type #><T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this <#= type #> measurement by a numaric scalar value.</summary>
        /// <param name="a">The <#= type #> measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static <#= type #><T> operator /(<#= type #><T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this <#= type #> measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public <#= type #><T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an <#= type #> measurement by another <#= type #> measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(<#= type #><T> a, <#= type #><T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an <#= type #> measurement by another <#= type #> measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(<#= type #><T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an <#= type #> measurement is less than another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(<#= type #><T> a, <#= type #><T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an <#= type #> measurement is less than another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(<#= type #><T> a, <#= type #><T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an <#= type #> measurement is less than another <#= type #> measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(<#= type #><T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an <#= type #> measurement is greater than another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(<#= type #><T> a, <#= type #><T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an <#= type #> measurement is greater than another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(<#= type #><T> a, <#= type #><T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an <#= type #> measurement is greater than another <#= type #> measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(<#= type #><T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an <#= type #> measurement is less than or equal to another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(<#= type #><T> a, <#= type #><T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an <#= type #> measurement is less than or equal to another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(<#= type #><T> a, <#= type #><T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an <#= type #> measurement is less than or equal to another <#= type #> measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(<#= type #><T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an <#= type #> measurement is greater than or equal to another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(<#= type #><T> a, <#= type #><T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an <#= type #> measurement is greater than or equal to another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(<#= type #><T> a, <#= type #><T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an <#= type #> measurement is greater than or equal to another <#= type #> measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(<#= type #><T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an <#= type #> measurement is equal to another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(<#= type #><T> a, <#= type #><T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an <#= type #> measurement is equal to another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(<#= type #><T> a, <#= type #><T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an <#= type #> measurement is equal to another <#= type #> measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(<#= type #><T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an <#= type #> measurement is not equal to another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(<#= type #><T> a, <#= type #><T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an <#= type #> measurement is not equal to another <#= type #> measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(<#= type #><T> a, <#= type #><T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an <#= type #> measurement is not equal to another <#= type #> measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(<#= type #><T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

<# } #>
}