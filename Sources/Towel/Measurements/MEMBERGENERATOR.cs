//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "MEMBERGENERATOR.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

using Towel.Mathematics;

namespace Towel.Measurements
{
	public partial struct Acceleration<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Acceleration measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Acceleration<T> Add(Acceleration<T> a, Acceleration<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Acceleration measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Acceleration<T> operator +(Acceleration<T> a, Acceleration<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Acceleration measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Acceleration<T> Add(Acceleration<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Acceleration measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Acceleration<T> Subtract(Acceleration<T> a, Acceleration<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Acceleration measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Acceleration<T> operator -(Acceleration<T> a, Acceleration<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Acceleration measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Acceleration<T> Subtract(Acceleration<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
        /// <param name="a">The Acceleration measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Acceleration<T> Multiply(Acceleration<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
        /// <param name="a">The Acceleration measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Acceleration<T> Multiply(T b, Acceleration<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
        /// <param name="a">The Acceleration measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Acceleration<T> operator *(Acceleration<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
        /// <param name="a">The Acceleration measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Acceleration<T> operator *(T b, Acceleration<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Acceleration<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Acceleration measurement by a numaric scalar value.</summary>
        /// <param name="a">The Acceleration measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Acceleration<T> Divide(Acceleration<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Acceleration measurement by a numaric scalar value.</summary>
        /// <param name="a">The Acceleration measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Acceleration<T> operator /(Acceleration<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Acceleration measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Acceleration<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Acceleration measurement by another Acceleration measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Acceleration<T> a, Acceleration<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Acceleration measurement by another Acceleration measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Acceleration<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Acceleration measurement is less than another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Acceleration<T> a, Acceleration<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Acceleration measurement is less than another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Acceleration<T> a, Acceleration<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Acceleration measurement is less than another Acceleration measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Acceleration<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Acceleration measurement is greater than another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Acceleration<T> a, Acceleration<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Acceleration measurement is greater than another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Acceleration<T> a, Acceleration<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Acceleration measurement is greater than another Acceleration measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Acceleration<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Acceleration measurement is less than or equal to another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Acceleration<T> a, Acceleration<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Acceleration measurement is less than or equal to another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Acceleration<T> a, Acceleration<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Acceleration measurement is less than or equal to another Acceleration measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Acceleration<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Acceleration measurement is greater than or equal to another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Acceleration<T> a, Acceleration<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Acceleration measurement is greater than or equal to another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Acceleration<T> a, Acceleration<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Acceleration measurement is greater than or equal to another Acceleration measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Acceleration<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Acceleration measurement is equal to another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Acceleration<T> a, Acceleration<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Acceleration measurement is equal to another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Acceleration<T> a, Acceleration<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Acceleration measurement is equal to another Acceleration measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Acceleration<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Acceleration measurement is not equal to another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Acceleration<T> a, Acceleration<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Acceleration measurement is not equal to another Acceleration measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Acceleration<T> a, Acceleration<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Acceleration measurement is not equal to another Acceleration measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Acceleration<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Angle<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Angle measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Angle<T> Add(Angle<T> a, Angle<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Angle measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Angle<T> operator +(Angle<T> a, Angle<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Angle measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Angle<T> Add(Angle<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Angle measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Angle<T> Subtract(Angle<T> a, Angle<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Angle measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Angle<T> operator -(Angle<T> a, Angle<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Angle measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Angle<T> Subtract(Angle<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Angle by a scalar numeric value.</summary>
        /// <param name="a">The Angle measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Angle<T> Multiply(Angle<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Angle by a scalar numeric value.</summary>
        /// <param name="a">The Angle measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Angle<T> Multiply(T b, Angle<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Angle by a scalar numeric value.</summary>
        /// <param name="a">The Angle measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Angle<T> operator *(Angle<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Angle by a scalar numeric value.</summary>
        /// <param name="a">The Angle measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Angle<T> operator *(T b, Angle<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Angle by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Angle<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Angle measurement by a numaric scalar value.</summary>
        /// <param name="a">The Angle measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Angle<T> Divide(Angle<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Angle measurement by a numaric scalar value.</summary>
        /// <param name="a">The Angle measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Angle<T> operator /(Angle<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Angle measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Angle<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Angle measurement by another Angle measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Angle<T> a, Angle<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Angle measurement by another Angle measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Angle<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Angle measurement is less than another Angle measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Angle<T> a, Angle<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Angle measurement is less than another Angle measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Angle<T> a, Angle<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Angle measurement is less than another Angle measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Angle<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Angle measurement is greater than another Angle measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Angle<T> a, Angle<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Angle measurement is greater than another Angle measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Angle<T> a, Angle<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Angle measurement is greater than another Angle measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Angle<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Angle measurement is less than or equal to another Angle measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Angle<T> a, Angle<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Angle measurement is less than or equal to another Angle measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Angle<T> a, Angle<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Angle measurement is less than or equal to another Angle measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Angle<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Angle measurement is greater than or equal to another Angle measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Angle<T> a, Angle<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Angle measurement is greater than or equal to another Angle measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Angle<T> a, Angle<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Angle measurement is greater than or equal to another Angle measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Angle<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Angle measurement is equal to another Angle measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Angle<T> a, Angle<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Angle measurement is equal to another Angle measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Angle<T> a, Angle<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Angle measurement is equal to another Angle measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Angle<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Angle measurement is not equal to another Angle measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Angle<T> a, Angle<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Angle measurement is not equal to another Angle measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Angle<T> a, Angle<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Angle measurement is not equal to another Angle measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Angle<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct AngularAcceleration<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two AngularAcceleration measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static AngularAcceleration<T> Add(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two AngularAcceleration measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static AngularAcceleration<T> operator +(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two AngularAcceleration measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public AngularAcceleration<T> Add(AngularAcceleration<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two AngularAcceleration measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static AngularAcceleration<T> Subtract(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two AngularAcceleration measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static AngularAcceleration<T> operator -(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two AngularAcceleration measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public AngularAcceleration<T> Subtract(AngularAcceleration<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
        /// <param name="a">The AngularAcceleration measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AngularAcceleration<T> Multiply(AngularAcceleration<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
        /// <param name="a">The AngularAcceleration measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AngularAcceleration<T> Multiply(T b, AngularAcceleration<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
        /// <param name="a">The AngularAcceleration measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AngularAcceleration<T> operator *(AngularAcceleration<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
        /// <param name="a">The AngularAcceleration measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AngularAcceleration<T> operator *(T b, AngularAcceleration<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public AngularAcceleration<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this AngularAcceleration measurement by a numaric scalar value.</summary>
        /// <param name="a">The AngularAcceleration measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static AngularAcceleration<T> Divide(AngularAcceleration<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this AngularAcceleration measurement by a numaric scalar value.</summary>
        /// <param name="a">The AngularAcceleration measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static AngularAcceleration<T> operator /(AngularAcceleration<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this AngularAcceleration measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public AngularAcceleration<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an AngularAcceleration measurement by another AngularAcceleration measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an AngularAcceleration measurement by another AngularAcceleration measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(AngularAcceleration<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an AngularAcceleration measurement is less than another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularAcceleration measurement is less than another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an AngularAcceleration measurement is less than another AngularAcceleration measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(AngularAcceleration<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an AngularAcceleration measurement is greater than another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularAcceleration measurement is greater than another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an AngularAcceleration measurement is greater than another AngularAcceleration measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(AngularAcceleration<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an AngularAcceleration measurement is less than or equal to another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularAcceleration measurement is less than or equal to another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an AngularAcceleration measurement is less than or equal to another AngularAcceleration measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(AngularAcceleration<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an AngularAcceleration measurement is greater than or equal to another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularAcceleration measurement is greater than or equal to another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an AngularAcceleration measurement is greater than or equal to another AngularAcceleration measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(AngularAcceleration<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an AngularAcceleration measurement is equal to another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularAcceleration measurement is equal to another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an AngularAcceleration measurement is equal to another AngularAcceleration measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(AngularAcceleration<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an AngularAcceleration measurement is not equal to another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularAcceleration measurement is not equal to another AngularAcceleration measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(AngularAcceleration<T> a, AngularAcceleration<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an AngularAcceleration measurement is not equal to another AngularAcceleration measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(AngularAcceleration<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct AngularSpeed<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two AngularSpeed measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static AngularSpeed<T> Add(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two AngularSpeed measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static AngularSpeed<T> operator +(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two AngularSpeed measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public AngularSpeed<T> Add(AngularSpeed<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two AngularSpeed measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static AngularSpeed<T> Subtract(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two AngularSpeed measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static AngularSpeed<T> operator -(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two AngularSpeed measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public AngularSpeed<T> Subtract(AngularSpeed<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
        /// <param name="a">The AngularSpeed measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AngularSpeed<T> Multiply(AngularSpeed<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
        /// <param name="a">The AngularSpeed measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AngularSpeed<T> Multiply(T b, AngularSpeed<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
        /// <param name="a">The AngularSpeed measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AngularSpeed<T> operator *(AngularSpeed<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
        /// <param name="a">The AngularSpeed measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AngularSpeed<T> operator *(T b, AngularSpeed<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public AngularSpeed<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this AngularSpeed measurement by a numaric scalar value.</summary>
        /// <param name="a">The AngularSpeed measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static AngularSpeed<T> Divide(AngularSpeed<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this AngularSpeed measurement by a numaric scalar value.</summary>
        /// <param name="a">The AngularSpeed measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static AngularSpeed<T> operator /(AngularSpeed<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this AngularSpeed measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public AngularSpeed<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an AngularSpeed measurement by another AngularSpeed measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an AngularSpeed measurement by another AngularSpeed measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(AngularSpeed<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an AngularSpeed measurement is less than another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularSpeed measurement is less than another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an AngularSpeed measurement is less than another AngularSpeed measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(AngularSpeed<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an AngularSpeed measurement is greater than another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularSpeed measurement is greater than another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an AngularSpeed measurement is greater than another AngularSpeed measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(AngularSpeed<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an AngularSpeed measurement is less than or equal to another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularSpeed measurement is less than or equal to another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an AngularSpeed measurement is less than or equal to another AngularSpeed measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(AngularSpeed<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an AngularSpeed measurement is greater than or equal to another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularSpeed measurement is greater than or equal to another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an AngularSpeed measurement is greater than or equal to another AngularSpeed measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(AngularSpeed<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an AngularSpeed measurement is equal to another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularSpeed measurement is equal to another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an AngularSpeed measurement is equal to another AngularSpeed measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(AngularSpeed<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an AngularSpeed measurement is not equal to another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AngularSpeed measurement is not equal to another AngularSpeed measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(AngularSpeed<T> a, AngularSpeed<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an AngularSpeed measurement is not equal to another AngularSpeed measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(AngularSpeed<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Area<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Area measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Area<T> Add(Area<T> a, Area<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Area measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Area<T> operator +(Area<T> a, Area<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Area measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Area<T> Add(Area<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Area measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Area<T> Subtract(Area<T> a, Area<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Area measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Area<T> operator -(Area<T> a, Area<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Area measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Area<T> Subtract(Area<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Area by a scalar numeric value.</summary>
        /// <param name="a">The Area measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Area<T> Multiply(Area<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Area by a scalar numeric value.</summary>
        /// <param name="a">The Area measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Area<T> Multiply(T b, Area<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Area by a scalar numeric value.</summary>
        /// <param name="a">The Area measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Area<T> operator *(Area<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Area by a scalar numeric value.</summary>
        /// <param name="a">The Area measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Area<T> operator *(T b, Area<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Area by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Area<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Area measurement by a numaric scalar value.</summary>
        /// <param name="a">The Area measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Area<T> Divide(Area<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Area measurement by a numaric scalar value.</summary>
        /// <param name="a">The Area measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Area<T> operator /(Area<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Area measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Area<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Area measurement by another Area measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Area<T> a, Area<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Area measurement by another Area measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Area<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Area measurement is less than another Area measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Area<T> a, Area<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Area measurement is less than another Area measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Area<T> a, Area<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Area measurement is less than another Area measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Area<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Area measurement is greater than another Area measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Area<T> a, Area<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Area measurement is greater than another Area measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Area<T> a, Area<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Area measurement is greater than another Area measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Area<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Area measurement is less than or equal to another Area measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Area<T> a, Area<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Area measurement is less than or equal to another Area measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Area<T> a, Area<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Area measurement is less than or equal to another Area measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Area<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Area measurement is greater than or equal to another Area measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Area<T> a, Area<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Area measurement is greater than or equal to another Area measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Area<T> a, Area<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Area measurement is greater than or equal to another Area measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Area<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Area measurement is equal to another Area measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Area<T> a, Area<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Area measurement is equal to another Area measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Area<T> a, Area<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Area measurement is equal to another Area measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Area<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Area measurement is not equal to another Area measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Area<T> a, Area<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Area measurement is not equal to another Area measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Area<T> a, Area<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Area measurement is not equal to another Area measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Area<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct AreaDensity<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two AreaDensity measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static AreaDensity<T> Add(AreaDensity<T> a, AreaDensity<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two AreaDensity measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static AreaDensity<T> operator +(AreaDensity<T> a, AreaDensity<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two AreaDensity measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public AreaDensity<T> Add(AreaDensity<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two AreaDensity measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static AreaDensity<T> Subtract(AreaDensity<T> a, AreaDensity<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two AreaDensity measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static AreaDensity<T> operator -(AreaDensity<T> a, AreaDensity<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two AreaDensity measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public AreaDensity<T> Subtract(AreaDensity<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
        /// <param name="a">The AreaDensity measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AreaDensity<T> Multiply(AreaDensity<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
        /// <param name="a">The AreaDensity measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AreaDensity<T> Multiply(T b, AreaDensity<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
        /// <param name="a">The AreaDensity measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AreaDensity<T> operator *(AreaDensity<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
        /// <param name="a">The AreaDensity measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static AreaDensity<T> operator *(T b, AreaDensity<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public AreaDensity<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this AreaDensity measurement by a numaric scalar value.</summary>
        /// <param name="a">The AreaDensity measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static AreaDensity<T> Divide(AreaDensity<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this AreaDensity measurement by a numaric scalar value.</summary>
        /// <param name="a">The AreaDensity measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static AreaDensity<T> operator /(AreaDensity<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this AreaDensity measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public AreaDensity<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an AreaDensity measurement by another AreaDensity measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(AreaDensity<T> a, AreaDensity<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an AreaDensity measurement by another AreaDensity measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(AreaDensity<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an AreaDensity measurement is less than another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(AreaDensity<T> a, AreaDensity<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an AreaDensity measurement is less than another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(AreaDensity<T> a, AreaDensity<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an AreaDensity measurement is less than another AreaDensity measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(AreaDensity<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an AreaDensity measurement is greater than another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(AreaDensity<T> a, AreaDensity<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an AreaDensity measurement is greater than another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(AreaDensity<T> a, AreaDensity<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an AreaDensity measurement is greater than another AreaDensity measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(AreaDensity<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an AreaDensity measurement is less than or equal to another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(AreaDensity<T> a, AreaDensity<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AreaDensity measurement is less than or equal to another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(AreaDensity<T> a, AreaDensity<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an AreaDensity measurement is less than or equal to another AreaDensity measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(AreaDensity<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an AreaDensity measurement is greater than or equal to another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(AreaDensity<T> a, AreaDensity<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AreaDensity measurement is greater than or equal to another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(AreaDensity<T> a, AreaDensity<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an AreaDensity measurement is greater than or equal to another AreaDensity measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(AreaDensity<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an AreaDensity measurement is equal to another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(AreaDensity<T> a, AreaDensity<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AreaDensity measurement is equal to another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(AreaDensity<T> a, AreaDensity<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an AreaDensity measurement is equal to another AreaDensity measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(AreaDensity<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an AreaDensity measurement is not equal to another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(AreaDensity<T> a, AreaDensity<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an AreaDensity measurement is not equal to another AreaDensity measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(AreaDensity<T> a, AreaDensity<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an AreaDensity measurement is not equal to another AreaDensity measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(AreaDensity<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Density<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Density measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Density<T> Add(Density<T> a, Density<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Density measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Density<T> operator +(Density<T> a, Density<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Density measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Density<T> Add(Density<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Density measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Density<T> Subtract(Density<T> a, Density<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Density measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Density<T> operator -(Density<T> a, Density<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Density measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Density<T> Subtract(Density<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Density by a scalar numeric value.</summary>
        /// <param name="a">The Density measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Density<T> Multiply(Density<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Density by a scalar numeric value.</summary>
        /// <param name="a">The Density measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Density<T> Multiply(T b, Density<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Density by a scalar numeric value.</summary>
        /// <param name="a">The Density measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Density<T> operator *(Density<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Density by a scalar numeric value.</summary>
        /// <param name="a">The Density measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Density<T> operator *(T b, Density<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Density by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Density<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Density measurement by a numaric scalar value.</summary>
        /// <param name="a">The Density measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Density<T> Divide(Density<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Density measurement by a numaric scalar value.</summary>
        /// <param name="a">The Density measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Density<T> operator /(Density<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Density measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Density<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Density measurement by another Density measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Density<T> a, Density<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Density measurement by another Density measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Density<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Density measurement is less than another Density measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Density<T> a, Density<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Density measurement is less than another Density measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Density<T> a, Density<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Density measurement is less than another Density measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Density<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Density measurement is greater than another Density measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Density<T> a, Density<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Density measurement is greater than another Density measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Density<T> a, Density<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Density measurement is greater than another Density measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Density<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Density measurement is less than or equal to another Density measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Density<T> a, Density<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Density measurement is less than or equal to another Density measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Density<T> a, Density<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Density measurement is less than or equal to another Density measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Density<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Density measurement is greater than or equal to another Density measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Density<T> a, Density<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Density measurement is greater than or equal to another Density measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Density<T> a, Density<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Density measurement is greater than or equal to another Density measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Density<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Density measurement is equal to another Density measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Density<T> a, Density<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Density measurement is equal to another Density measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Density<T> a, Density<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Density measurement is equal to another Density measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Density<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Density measurement is not equal to another Density measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Density<T> a, Density<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Density measurement is not equal to another Density measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Density<T> a, Density<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Density measurement is not equal to another Density measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Density<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct ElectricCharge<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two ElectricCharge measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static ElectricCharge<T> Add(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two ElectricCharge measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static ElectricCharge<T> operator +(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two ElectricCharge measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public ElectricCharge<T> Add(ElectricCharge<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two ElectricCharge measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static ElectricCharge<T> Subtract(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two ElectricCharge measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static ElectricCharge<T> operator -(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two ElectricCharge measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public ElectricCharge<T> Subtract(ElectricCharge<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
        /// <param name="a">The ElectricCharge measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static ElectricCharge<T> Multiply(ElectricCharge<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
        /// <param name="a">The ElectricCharge measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static ElectricCharge<T> Multiply(T b, ElectricCharge<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
        /// <param name="a">The ElectricCharge measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static ElectricCharge<T> operator *(ElectricCharge<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
        /// <param name="a">The ElectricCharge measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static ElectricCharge<T> operator *(T b, ElectricCharge<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public ElectricCharge<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this ElectricCharge measurement by a numaric scalar value.</summary>
        /// <param name="a">The ElectricCharge measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static ElectricCharge<T> Divide(ElectricCharge<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this ElectricCharge measurement by a numaric scalar value.</summary>
        /// <param name="a">The ElectricCharge measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static ElectricCharge<T> operator /(ElectricCharge<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this ElectricCharge measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public ElectricCharge<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an ElectricCharge measurement by another ElectricCharge measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an ElectricCharge measurement by another ElectricCharge measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(ElectricCharge<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an ElectricCharge measurement is less than another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCharge measurement is less than another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an ElectricCharge measurement is less than another ElectricCharge measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(ElectricCharge<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an ElectricCharge measurement is greater than another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCharge measurement is greater than another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an ElectricCharge measurement is greater than another ElectricCharge measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(ElectricCharge<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an ElectricCharge measurement is less than or equal to another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCharge measurement is less than or equal to another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an ElectricCharge measurement is less than or equal to another ElectricCharge measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(ElectricCharge<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an ElectricCharge measurement is greater than or equal to another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCharge measurement is greater than or equal to another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an ElectricCharge measurement is greater than or equal to another ElectricCharge measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(ElectricCharge<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an ElectricCharge measurement is equal to another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCharge measurement is equal to another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an ElectricCharge measurement is equal to another ElectricCharge measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(ElectricCharge<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an ElectricCharge measurement is not equal to another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCharge measurement is not equal to another ElectricCharge measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(ElectricCharge<T> a, ElectricCharge<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an ElectricCharge measurement is not equal to another ElectricCharge measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(ElectricCharge<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct ElectricCurrent<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two ElectricCurrent measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static ElectricCurrent<T> Add(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two ElectricCurrent measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static ElectricCurrent<T> operator +(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two ElectricCurrent measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public ElectricCurrent<T> Add(ElectricCurrent<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two ElectricCurrent measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static ElectricCurrent<T> Subtract(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two ElectricCurrent measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static ElectricCurrent<T> operator -(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two ElectricCurrent measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public ElectricCurrent<T> Subtract(ElectricCurrent<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
        /// <param name="a">The ElectricCurrent measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static ElectricCurrent<T> Multiply(ElectricCurrent<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
        /// <param name="a">The ElectricCurrent measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static ElectricCurrent<T> Multiply(T b, ElectricCurrent<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
        /// <param name="a">The ElectricCurrent measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static ElectricCurrent<T> operator *(ElectricCurrent<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
        /// <param name="a">The ElectricCurrent measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static ElectricCurrent<T> operator *(T b, ElectricCurrent<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public ElectricCurrent<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this ElectricCurrent measurement by a numaric scalar value.</summary>
        /// <param name="a">The ElectricCurrent measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static ElectricCurrent<T> Divide(ElectricCurrent<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this ElectricCurrent measurement by a numaric scalar value.</summary>
        /// <param name="a">The ElectricCurrent measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static ElectricCurrent<T> operator /(ElectricCurrent<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this ElectricCurrent measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public ElectricCurrent<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an ElectricCurrent measurement by another ElectricCurrent measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an ElectricCurrent measurement by another ElectricCurrent measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(ElectricCurrent<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an ElectricCurrent measurement is less than another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCurrent measurement is less than another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an ElectricCurrent measurement is less than another ElectricCurrent measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(ElectricCurrent<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an ElectricCurrent measurement is greater than another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCurrent measurement is greater than another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an ElectricCurrent measurement is greater than another ElectricCurrent measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(ElectricCurrent<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an ElectricCurrent measurement is less than or equal to another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCurrent measurement is less than or equal to another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an ElectricCurrent measurement is less than or equal to another ElectricCurrent measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(ElectricCurrent<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an ElectricCurrent measurement is greater than or equal to another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCurrent measurement is greater than or equal to another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an ElectricCurrent measurement is greater than or equal to another ElectricCurrent measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(ElectricCurrent<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an ElectricCurrent measurement is equal to another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCurrent measurement is equal to another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an ElectricCurrent measurement is equal to another ElectricCurrent measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(ElectricCurrent<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an ElectricCurrent measurement is not equal to another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an ElectricCurrent measurement is not equal to another ElectricCurrent measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(ElectricCurrent<T> a, ElectricCurrent<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an ElectricCurrent measurement is not equal to another ElectricCurrent measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(ElectricCurrent<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Force<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Force measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Force<T> Add(Force<T> a, Force<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Force measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Force<T> operator +(Force<T> a, Force<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Force measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Force<T> Add(Force<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Force measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Force<T> Subtract(Force<T> a, Force<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Force measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Force<T> operator -(Force<T> a, Force<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Force measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Force<T> Subtract(Force<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Force by a scalar numeric value.</summary>
        /// <param name="a">The Force measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Force<T> Multiply(Force<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Force by a scalar numeric value.</summary>
        /// <param name="a">The Force measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Force<T> Multiply(T b, Force<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Force by a scalar numeric value.</summary>
        /// <param name="a">The Force measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Force<T> operator *(Force<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Force by a scalar numeric value.</summary>
        /// <param name="a">The Force measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Force<T> operator *(T b, Force<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Force by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Force<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Force measurement by a numaric scalar value.</summary>
        /// <param name="a">The Force measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Force<T> Divide(Force<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Force measurement by a numaric scalar value.</summary>
        /// <param name="a">The Force measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Force<T> operator /(Force<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Force measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Force<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Force measurement by another Force measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Force<T> a, Force<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Force measurement by another Force measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Force<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Force measurement is less than another Force measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Force<T> a, Force<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Force measurement is less than another Force measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Force<T> a, Force<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Force measurement is less than another Force measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Force<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Force measurement is greater than another Force measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Force<T> a, Force<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Force measurement is greater than another Force measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Force<T> a, Force<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Force measurement is greater than another Force measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Force<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Force measurement is less than or equal to another Force measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Force<T> a, Force<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Force measurement is less than or equal to another Force measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Force<T> a, Force<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Force measurement is less than or equal to another Force measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Force<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Force measurement is greater than or equal to another Force measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Force<T> a, Force<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Force measurement is greater than or equal to another Force measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Force<T> a, Force<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Force measurement is greater than or equal to another Force measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Force<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Force measurement is equal to another Force measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Force<T> a, Force<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Force measurement is equal to another Force measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Force<T> a, Force<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Force measurement is equal to another Force measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Force<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Force measurement is not equal to another Force measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Force<T> a, Force<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Force measurement is not equal to another Force measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Force<T> a, Force<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Force measurement is not equal to another Force measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Force<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Length<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Length measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Length<T> Add(Length<T> a, Length<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Length measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Length<T> operator +(Length<T> a, Length<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Length measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Length<T> Add(Length<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Length measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Length<T> Subtract(Length<T> a, Length<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Length measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Length<T> operator -(Length<T> a, Length<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Length measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Length<T> Subtract(Length<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Length by a scalar numeric value.</summary>
        /// <param name="a">The Length measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Length<T> Multiply(Length<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Length by a scalar numeric value.</summary>
        /// <param name="a">The Length measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Length<T> Multiply(T b, Length<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Length by a scalar numeric value.</summary>
        /// <param name="a">The Length measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Length<T> operator *(Length<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Length by a scalar numeric value.</summary>
        /// <param name="a">The Length measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Length<T> operator *(T b, Length<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Length by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Length<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Length measurement by a numaric scalar value.</summary>
        /// <param name="a">The Length measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Length<T> Divide(Length<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Length measurement by a numaric scalar value.</summary>
        /// <param name="a">The Length measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Length<T> operator /(Length<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Length measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Length<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Length measurement by another Length measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Length<T> a, Length<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Length measurement by another Length measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Length<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Length measurement is less than another Length measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Length<T> a, Length<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Length measurement is less than another Length measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Length<T> a, Length<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Length measurement is less than another Length measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Length<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Length measurement is greater than another Length measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Length<T> a, Length<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Length measurement is greater than another Length measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Length<T> a, Length<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Length measurement is greater than another Length measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Length<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Length measurement is less than or equal to another Length measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Length<T> a, Length<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Length measurement is less than or equal to another Length measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Length<T> a, Length<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Length measurement is less than or equal to another Length measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Length<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Length measurement is greater than or equal to another Length measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Length<T> a, Length<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Length measurement is greater than or equal to another Length measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Length<T> a, Length<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Length measurement is greater than or equal to another Length measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Length<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Length measurement is equal to another Length measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Length<T> a, Length<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Length measurement is equal to another Length measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Length<T> a, Length<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Length measurement is equal to another Length measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Length<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Length measurement is not equal to another Length measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Length<T> a, Length<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Length measurement is not equal to another Length measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Length<T> a, Length<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Length measurement is not equal to another Length measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Length<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct LinearDensity<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two LinearDensity measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static LinearDensity<T> Add(LinearDensity<T> a, LinearDensity<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two LinearDensity measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static LinearDensity<T> operator +(LinearDensity<T> a, LinearDensity<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two LinearDensity measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public LinearDensity<T> Add(LinearDensity<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two LinearDensity measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static LinearDensity<T> Subtract(LinearDensity<T> a, LinearDensity<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two LinearDensity measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static LinearDensity<T> operator -(LinearDensity<T> a, LinearDensity<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two LinearDensity measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public LinearDensity<T> Subtract(LinearDensity<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
        /// <param name="a">The LinearDensity measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearDensity<T> Multiply(LinearDensity<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
        /// <param name="a">The LinearDensity measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearDensity<T> Multiply(T b, LinearDensity<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
        /// <param name="a">The LinearDensity measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearDensity<T> operator *(LinearDensity<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
        /// <param name="a">The LinearDensity measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearDensity<T> operator *(T b, LinearDensity<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public LinearDensity<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this LinearDensity measurement by a numaric scalar value.</summary>
        /// <param name="a">The LinearDensity measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static LinearDensity<T> Divide(LinearDensity<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this LinearDensity measurement by a numaric scalar value.</summary>
        /// <param name="a">The LinearDensity measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static LinearDensity<T> operator /(LinearDensity<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this LinearDensity measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public LinearDensity<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an LinearDensity measurement by another LinearDensity measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(LinearDensity<T> a, LinearDensity<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an LinearDensity measurement by another LinearDensity measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(LinearDensity<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an LinearDensity measurement is less than another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(LinearDensity<T> a, LinearDensity<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearDensity measurement is less than another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(LinearDensity<T> a, LinearDensity<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an LinearDensity measurement is less than another LinearDensity measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(LinearDensity<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an LinearDensity measurement is greater than another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(LinearDensity<T> a, LinearDensity<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearDensity measurement is greater than another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(LinearDensity<T> a, LinearDensity<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an LinearDensity measurement is greater than another LinearDensity measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(LinearDensity<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an LinearDensity measurement is less than or equal to another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(LinearDensity<T> a, LinearDensity<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearDensity measurement is less than or equal to another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(LinearDensity<T> a, LinearDensity<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an LinearDensity measurement is less than or equal to another LinearDensity measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(LinearDensity<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an LinearDensity measurement is greater than or equal to another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(LinearDensity<T> a, LinearDensity<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearDensity measurement is greater than or equal to another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(LinearDensity<T> a, LinearDensity<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an LinearDensity measurement is greater than or equal to another LinearDensity measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(LinearDensity<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an LinearDensity measurement is equal to another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(LinearDensity<T> a, LinearDensity<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearDensity measurement is equal to another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(LinearDensity<T> a, LinearDensity<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an LinearDensity measurement is equal to another LinearDensity measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(LinearDensity<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an LinearDensity measurement is not equal to another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(LinearDensity<T> a, LinearDensity<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearDensity measurement is not equal to another LinearDensity measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(LinearDensity<T> a, LinearDensity<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an LinearDensity measurement is not equal to another LinearDensity measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(LinearDensity<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct LinearMass<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two LinearMass measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static LinearMass<T> Add(LinearMass<T> a, LinearMass<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two LinearMass measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static LinearMass<T> operator +(LinearMass<T> a, LinearMass<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two LinearMass measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public LinearMass<T> Add(LinearMass<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two LinearMass measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static LinearMass<T> Subtract(LinearMass<T> a, LinearMass<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two LinearMass measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static LinearMass<T> operator -(LinearMass<T> a, LinearMass<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two LinearMass measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public LinearMass<T> Subtract(LinearMass<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
        /// <param name="a">The LinearMass measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearMass<T> Multiply(LinearMass<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
        /// <param name="a">The LinearMass measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearMass<T> Multiply(T b, LinearMass<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
        /// <param name="a">The LinearMass measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearMass<T> operator *(LinearMass<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
        /// <param name="a">The LinearMass measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearMass<T> operator *(T b, LinearMass<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public LinearMass<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this LinearMass measurement by a numaric scalar value.</summary>
        /// <param name="a">The LinearMass measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static LinearMass<T> Divide(LinearMass<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this LinearMass measurement by a numaric scalar value.</summary>
        /// <param name="a">The LinearMass measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static LinearMass<T> operator /(LinearMass<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this LinearMass measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public LinearMass<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an LinearMass measurement by another LinearMass measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(LinearMass<T> a, LinearMass<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an LinearMass measurement by another LinearMass measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(LinearMass<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an LinearMass measurement is less than another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(LinearMass<T> a, LinearMass<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMass measurement is less than another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(LinearMass<T> a, LinearMass<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an LinearMass measurement is less than another LinearMass measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(LinearMass<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an LinearMass measurement is greater than another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(LinearMass<T> a, LinearMass<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMass measurement is greater than another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(LinearMass<T> a, LinearMass<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an LinearMass measurement is greater than another LinearMass measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(LinearMass<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an LinearMass measurement is less than or equal to another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(LinearMass<T> a, LinearMass<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMass measurement is less than or equal to another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(LinearMass<T> a, LinearMass<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an LinearMass measurement is less than or equal to another LinearMass measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(LinearMass<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an LinearMass measurement is greater than or equal to another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(LinearMass<T> a, LinearMass<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMass measurement is greater than or equal to another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(LinearMass<T> a, LinearMass<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an LinearMass measurement is greater than or equal to another LinearMass measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(LinearMass<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an LinearMass measurement is equal to another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(LinearMass<T> a, LinearMass<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMass measurement is equal to another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(LinearMass<T> a, LinearMass<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an LinearMass measurement is equal to another LinearMass measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(LinearMass<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an LinearMass measurement is not equal to another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(LinearMass<T> a, LinearMass<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMass measurement is not equal to another LinearMass measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(LinearMass<T> a, LinearMass<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an LinearMass measurement is not equal to another LinearMass measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(LinearMass<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct LinearMassFlow<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two LinearMassFlow measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static LinearMassFlow<T> Add(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two LinearMassFlow measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static LinearMassFlow<T> operator +(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two LinearMassFlow measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public LinearMassFlow<T> Add(LinearMassFlow<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two LinearMassFlow measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static LinearMassFlow<T> Subtract(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two LinearMassFlow measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static LinearMassFlow<T> operator -(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two LinearMassFlow measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public LinearMassFlow<T> Subtract(LinearMassFlow<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
        /// <param name="a">The LinearMassFlow measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearMassFlow<T> Multiply(LinearMassFlow<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
        /// <param name="a">The LinearMassFlow measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearMassFlow<T> Multiply(T b, LinearMassFlow<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
        /// <param name="a">The LinearMassFlow measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearMassFlow<T> operator *(LinearMassFlow<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
        /// <param name="a">The LinearMassFlow measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static LinearMassFlow<T> operator *(T b, LinearMassFlow<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public LinearMassFlow<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this LinearMassFlow measurement by a numaric scalar value.</summary>
        /// <param name="a">The LinearMassFlow measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static LinearMassFlow<T> Divide(LinearMassFlow<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this LinearMassFlow measurement by a numaric scalar value.</summary>
        /// <param name="a">The LinearMassFlow measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static LinearMassFlow<T> operator /(LinearMassFlow<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this LinearMassFlow measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public LinearMassFlow<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an LinearMassFlow measurement by another LinearMassFlow measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an LinearMassFlow measurement by another LinearMassFlow measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(LinearMassFlow<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an LinearMassFlow measurement is less than another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMassFlow measurement is less than another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an LinearMassFlow measurement is less than another LinearMassFlow measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(LinearMassFlow<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an LinearMassFlow measurement is greater than another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMassFlow measurement is greater than another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an LinearMassFlow measurement is greater than another LinearMassFlow measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(LinearMassFlow<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an LinearMassFlow measurement is less than or equal to another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMassFlow measurement is less than or equal to another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an LinearMassFlow measurement is less than or equal to another LinearMassFlow measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(LinearMassFlow<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an LinearMassFlow measurement is greater than or equal to another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMassFlow measurement is greater than or equal to another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an LinearMassFlow measurement is greater than or equal to another LinearMassFlow measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(LinearMassFlow<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an LinearMassFlow measurement is equal to another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMassFlow measurement is equal to another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an LinearMassFlow measurement is equal to another LinearMassFlow measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(LinearMassFlow<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an LinearMassFlow measurement is not equal to another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an LinearMassFlow measurement is not equal to another LinearMassFlow measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(LinearMassFlow<T> a, LinearMassFlow<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an LinearMassFlow measurement is not equal to another LinearMassFlow measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(LinearMassFlow<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Mass<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Mass measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Mass<T> Add(Mass<T> a, Mass<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Mass measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Mass<T> operator +(Mass<T> a, Mass<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Mass measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Mass<T> Add(Mass<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Mass measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Mass<T> Subtract(Mass<T> a, Mass<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Mass measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Mass<T> operator -(Mass<T> a, Mass<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Mass measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Mass<T> Subtract(Mass<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Mass by a scalar numeric value.</summary>
        /// <param name="a">The Mass measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Mass<T> Multiply(Mass<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Mass by a scalar numeric value.</summary>
        /// <param name="a">The Mass measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Mass<T> Multiply(T b, Mass<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Mass by a scalar numeric value.</summary>
        /// <param name="a">The Mass measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Mass<T> operator *(Mass<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Mass by a scalar numeric value.</summary>
        /// <param name="a">The Mass measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Mass<T> operator *(T b, Mass<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Mass by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Mass<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Mass measurement by a numaric scalar value.</summary>
        /// <param name="a">The Mass measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Mass<T> Divide(Mass<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Mass measurement by a numaric scalar value.</summary>
        /// <param name="a">The Mass measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Mass<T> operator /(Mass<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Mass measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Mass<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Mass measurement by another Mass measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Mass<T> a, Mass<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Mass measurement by another Mass measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Mass<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Mass measurement is less than another Mass measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Mass<T> a, Mass<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Mass measurement is less than another Mass measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Mass<T> a, Mass<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Mass measurement is less than another Mass measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Mass<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Mass measurement is greater than another Mass measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Mass<T> a, Mass<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Mass measurement is greater than another Mass measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Mass<T> a, Mass<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Mass measurement is greater than another Mass measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Mass<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Mass measurement is less than or equal to another Mass measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Mass<T> a, Mass<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Mass measurement is less than or equal to another Mass measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Mass<T> a, Mass<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Mass measurement is less than or equal to another Mass measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Mass<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Mass measurement is greater than or equal to another Mass measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Mass<T> a, Mass<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Mass measurement is greater than or equal to another Mass measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Mass<T> a, Mass<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Mass measurement is greater than or equal to another Mass measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Mass<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Mass measurement is equal to another Mass measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Mass<T> a, Mass<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Mass measurement is equal to another Mass measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Mass<T> a, Mass<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Mass measurement is equal to another Mass measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Mass<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Mass measurement is not equal to another Mass measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Mass<T> a, Mass<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Mass measurement is not equal to another Mass measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Mass<T> a, Mass<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Mass measurement is not equal to another Mass measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Mass<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Speed<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Speed measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Speed<T> Add(Speed<T> a, Speed<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Speed measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Speed<T> operator +(Speed<T> a, Speed<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Speed measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Speed<T> Add(Speed<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Speed measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Speed<T> Subtract(Speed<T> a, Speed<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Speed measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Speed<T> operator -(Speed<T> a, Speed<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Speed measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Speed<T> Subtract(Speed<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Speed by a scalar numeric value.</summary>
        /// <param name="a">The Speed measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Speed<T> Multiply(Speed<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Speed by a scalar numeric value.</summary>
        /// <param name="a">The Speed measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Speed<T> Multiply(T b, Speed<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Speed by a scalar numeric value.</summary>
        /// <param name="a">The Speed measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Speed<T> operator *(Speed<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Speed by a scalar numeric value.</summary>
        /// <param name="a">The Speed measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Speed<T> operator *(T b, Speed<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Speed by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Speed<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Speed measurement by a numaric scalar value.</summary>
        /// <param name="a">The Speed measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Speed<T> Divide(Speed<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Speed measurement by a numaric scalar value.</summary>
        /// <param name="a">The Speed measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Speed<T> operator /(Speed<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Speed measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Speed<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Speed measurement by another Speed measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Speed<T> a, Speed<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Speed measurement by another Speed measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Speed<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Speed measurement is less than another Speed measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Speed<T> a, Speed<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Speed measurement is less than another Speed measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Speed<T> a, Speed<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Speed measurement is less than another Speed measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Speed<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Speed measurement is greater than another Speed measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Speed<T> a, Speed<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Speed measurement is greater than another Speed measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Speed<T> a, Speed<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Speed measurement is greater than another Speed measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Speed<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Speed measurement is less than or equal to another Speed measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Speed<T> a, Speed<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Speed measurement is less than or equal to another Speed measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Speed<T> a, Speed<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Speed measurement is less than or equal to another Speed measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Speed<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Speed measurement is greater than or equal to another Speed measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Speed<T> a, Speed<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Speed measurement is greater than or equal to another Speed measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Speed<T> a, Speed<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Speed measurement is greater than or equal to another Speed measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Speed<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Speed measurement is equal to another Speed measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Speed<T> a, Speed<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Speed measurement is equal to another Speed measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Speed<T> a, Speed<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Speed measurement is equal to another Speed measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Speed<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Speed measurement is not equal to another Speed measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Speed<T> a, Speed<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Speed measurement is not equal to another Speed measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Speed<T> a, Speed<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Speed measurement is not equal to another Speed measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Speed<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Time<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Time measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Time<T> Add(Time<T> a, Time<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Time measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Time<T> operator +(Time<T> a, Time<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Time measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Time<T> Add(Time<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Time measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Time<T> Subtract(Time<T> a, Time<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Time measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Time<T> operator -(Time<T> a, Time<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Time measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Time<T> Subtract(Time<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Time by a scalar numeric value.</summary>
        /// <param name="a">The Time measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Time<T> Multiply(Time<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Time by a scalar numeric value.</summary>
        /// <param name="a">The Time measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Time<T> Multiply(T b, Time<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Time by a scalar numeric value.</summary>
        /// <param name="a">The Time measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Time<T> operator *(Time<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Time by a scalar numeric value.</summary>
        /// <param name="a">The Time measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Time<T> operator *(T b, Time<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Time by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Time<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Time measurement by a numaric scalar value.</summary>
        /// <param name="a">The Time measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Time<T> Divide(Time<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Time measurement by a numaric scalar value.</summary>
        /// <param name="a">The Time measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Time<T> operator /(Time<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Time measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Time<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Time measurement by another Time measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Time<T> a, Time<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Time measurement by another Time measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Time<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Time measurement is less than another Time measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Time<T> a, Time<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Time measurement is less than another Time measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Time<T> a, Time<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Time measurement is less than another Time measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Time<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Time measurement is greater than another Time measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Time<T> a, Time<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Time measurement is greater than another Time measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Time<T> a, Time<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Time measurement is greater than another Time measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Time<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Time measurement is less than or equal to another Time measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Time<T> a, Time<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Time measurement is less than or equal to another Time measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Time<T> a, Time<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Time measurement is less than or equal to another Time measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Time<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Time measurement is greater than or equal to another Time measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Time<T> a, Time<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Time measurement is greater than or equal to another Time measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Time<T> a, Time<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Time measurement is greater than or equal to another Time measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Time<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Time measurement is equal to another Time measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Time<T> a, Time<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Time measurement is equal to another Time measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Time<T> a, Time<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Time measurement is equal to another Time measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Time<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Time measurement is not equal to another Time measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Time<T> a, Time<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Time measurement is not equal to another Time measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Time<T> a, Time<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Time measurement is not equal to another Time measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Time<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

	public partial struct Volume<T>
	{
        #region Mathematics

        #region Add

        /// <summary>Adds two Volume measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Volume<T> Add(Volume<T> a, Volume<T> b)
        {
            return MathBase(a, b, Compute.AddImplementation<T>.Function);
        }

        /// <summary>Adds two Volume measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static Volume<T> operator +(Volume<T> a, Volume<T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two Volume measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public Volume<T> Add(Volume<T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two Volume measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Volume<T> Subtract(Volume<T> a, Volume<T> b)
        {
            return MathBase(a, b, Compute.SubtractImplementation<T>.Function);
        }

        /// <summary>Subtracts two Volume measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static Volume<T> operator -(Volume<T> a, Volume<T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two Volume measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public Volume<T> Subtract(Volume<T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an Volume by a scalar numeric value.</summary>
        /// <param name="a">The Volume measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Volume<T> Multiply(Volume<T> a, T b)
        {
            return MathBase(a, b, Compute.MultiplyImplementation<T>.Function);
        }

        /// <summary>Multiplies an Volume by a scalar numeric value.</summary>
        /// <param name="a">The Volume measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Volume<T> Multiply(T b, Volume<T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Volume by a scalar numeric value.</summary>
        /// <param name="a">The Volume measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Volume<T> operator *(Volume<T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an Volume by a scalar numeric value.</summary>
        /// <param name="a">The Volume measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static Volume<T> operator *(T b, Volume<T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an Volume by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public Volume<T> Add(T b)
        {
            return this * b;
        }

        #endregion

        #region Divide

        /// <summary>Divides this Volume measurement by a numaric scalar value.</summary>
        /// <param name="a">The Volume measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Volume<T> Divide(Volume<T> a, T b)
        {
            return MathBase(a, b, Compute.DivideImplementation<T>.Function);
        }

        /// <summary>Divides this Volume measurement by a numaric scalar value.</summary>
        /// <param name="a">The Volume measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static Volume<T> operator /(Volume<T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this Volume measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public Volume<T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an Volume measurement by another Volume measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(Volume<T> a, Volume<T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an Volume measurement by another Volume measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(Volume<T> b)
        {
            return this / b;
        }

        #endregion

        #region LessThan

        /// <summary>Determines if an Volume measurement is less than another Volume measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(Volume<T> a, Volume<T> b)
        {
            return LogicBase(a, b, Compute.LessThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Volume measurement is less than another Volume measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(Volume<T> a, Volume<T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an Volume measurement is less than another Volume measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(Volume<T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an Volume measurement is greater than another Volume measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(Volume<T> a, Volume<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanImplementation<T>.Function);
        }

        /// <summary>Determines if an Volume measurement is greater than another Volume measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(Volume<T> a, Volume<T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an Volume measurement is greater than another Volume measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(Volume<T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an Volume measurement is less than or equal to another Volume measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(Volume<T> a, Volume<T> b)
        {
            return LogicBase(a, b, Compute.LessThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Volume measurement is less than or equal to another Volume measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(Volume<T> a, Volume<T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an Volume measurement is less than or equal to another Volume measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(Volume<T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an Volume measurement is greater than or equal to another Volume measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(Volume<T> a, Volume<T> b)
        {
            return LogicBase(a, b, Compute.GreaterThanOrEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Volume measurement is greater than or equal to another Volume measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(Volume<T> a, Volume<T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an Volume measurement is greater than or equal to another Volume measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(Volume<T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an Volume measurement is equal to another Volume measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(Volume<T> a, Volume<T> b)
        {
            return LogicBase(a, b, Compute.EqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Volume measurement is equal to another Volume measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(Volume<T> a, Volume<T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an Volume measurement is equal to another Volume measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(Volume<T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an Volume measurement is not equal to another Volume measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(Volume<T> a, Volume<T> b)
        {
            return LogicBase(a, b, Compute.NotEqualImplementation<T>.Function);
        }

        /// <summary>Determines if an Volume measurement is not equal to another Volume measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(Volume<T> a, Volume<T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an Volume measurement is not equal to another Volume measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(Volume<T> b)
        {
            return this != b;
        }

        #endregion

        #endregion
	}

}